<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K线图实例</title>
    <style type="text/css">
        body {
            background-color: rgb(33, 33, 45);
        }
    </style>
</head>

<body>

<div id="chart" height="500" width="1200" style="margin:30px;"></div>
<script src="http://192.168.1.100:5000/static/monthly.js"></script>
<script type="text/javascript">
    // [
    //     {'year': 2007, 'month': 1, 'avg_temp': 5.5, 'amt_rain': 84.5, 'num_rain': 14, 'num_snow': 4, 'num_storm': 0, 'num_fire': 8, 'max_level_fire': 1},
    //     {'year': 2007, 'month': 2, 'avg_temp': 11.2, 'amt_rain': 56.7, 'num_rain': 10, 'num_snow': 0, 'num_storm': 0, 'num_fire': 10, 'max_level_fire': 1}
    // ];
    function drawRightUpPanel() {


        let dataArr = [];

        let mousePosition = {}; //用户存放鼠标位置

        let point_avg_temp = [];
        let point_amt_rain = [];
        let point_num_rain = [];

        let canvas = document.createElement("canvas");
        let ctx = canvas.getContext("2d");

        let cBox = document.getElementById("chart");
        cBox.appendChild(canvas);

        let cMargin = 40;
        let cSpace = 80;

        canvas.width = cBox.getAttribute("width") * 2;
        canvas.height = cBox.getAttribute("height") * 2;
        canvas.style.height = canvas.height / 2 + "px";
        canvas.style.width = canvas.width / 2 + "px";
        let cHeight = canvas.height - cMargin * 2 - cSpace * 2;
        let cWidth = canvas.width - cMargin * 2 - cSpace * 2;
        let originX = cMargin + cSpace;
        let originY = cMargin + cHeight;

        // 柱状图信息
        let totalBars = monthly.length;
        let bWidth = cWidth / totalBars / 3;
        let bMargin = (cWidth - bWidth * totalBars) / (totalBars + 1);
        let maxValue = 200;
        let minValue = 0;
        let totalYNumber = 10;

        let dragBarWidth = 10;
        let dragBarX = cWidth + cSpace + cMargin - dragBarWidth;


        drawRightUpPanel.properties = {
            'avg_temp': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(251, 61, 95, 1)'},
            'amt_rain': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(47, 69, 84, 1)'},
            'num_rain': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(97, 160, 168, 1)'},
            'num_snow': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(97, 160, 168, 1)'},
            'num_storm': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)'},
            'num_fire': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)'},
            'max_level_fire': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)'},
        }

        drawRightUpPanel.points = {
            'avg_temp': [],
            'amt_rain': [],
            'num_rain': [],
            'num_snow': [],
            'num_storm': [],
            'num_fire': [],
            'max_level_fire': [],
        }
        loaded();

        function loaded() {
            let prop = drawRightUpPanel.properties;
            for (const monthlyElement of monthly) {
                prop.avg_temp.rng_max = Math.max(prop.avg_temp.rng_max, monthlyElement.avg_temp);
                prop.avg_temp.rng_min = Math.min(prop.avg_temp.rng_min, monthlyElement.avg_temp);

                prop.amt_rain.rng_max = Math.max(prop.amt_rain.rng_max, monthlyElement.amt_rain);
                prop.amt_rain.rng_min = Math.min(prop.amt_rain.rng_min, monthlyElement.amt_rain);

                prop.num_rain.rng_max = Math.max(prop.num_rain.rng_max, monthlyElement.num_rain);
                prop.num_rain.rng_min = Math.min(prop.num_rain.rng_min, monthlyElement.num_rain);

                prop.num_snow.rng_max = Math.max(prop.num_snow.rng_max, monthlyElement.num_snow);
                prop.num_snow.rng_min = Math.min(prop.num_snow.rng_min, monthlyElement.num_snow);

                prop.num_storm.rng_max = Math.max(prop.num_storm.rng_max, monthlyElement.num_storm);
                prop.num_storm.rng_min = Math.min(prop.num_storm.rng_min, monthlyElement.num_storm);

                prop.num_fire.rng_max = Math.max(prop.num_fire.rng_max, monthlyElement.num_fire);
                prop.num_fire.rng_min = Math.min(prop.num_fire.rng_min, monthlyElement.num_fire);

                prop.max_level_fire.rng_max = Math.max(prop.max_level_fire.rng_max, monthlyElement.max_level_fire);
                prop.max_level_fire.rng_min = Math.min(prop.max_level_fire.rng_min, monthlyElement.max_level_fire);
            }
            Object.keys(drawRightUpPanel.properties).forEach(key => {
                let diff = 0.05 * (drawRightUpPanel.properties[key].rng_max - drawRightUpPanel.properties[key].rng_min);
                console.log(diff)
                drawRightUpPanel.properties[key].rng_max += diff;
                drawRightUpPanel.properties[key].rng_min -= diff;
            });

            let points = drawRightUpPanel.points;
            for (let i = 0; i < monthly.length; i++) {
                let x = originX + (bWidth + bMargin) * i + bMargin + bWidth / 2;

                points.avg_temp.push({x: x, y: originY - cHeight * (monthly[i].avg_temp - prop.avg_temp.rng_min) / (prop.avg_temp.rng_max - prop.avg_temp.rng_min)});
                points.amt_rain.push({x: x, y: originY - cHeight * (monthly[i].amt_rain - prop.amt_rain.rng_min) / (prop.amt_rain.rng_max - prop.amt_rain.rng_min)});
                points.num_rain.push({x: x, y: originY - cHeight * (monthly[i].num_rain - prop.num_rain.rng_min) / (prop.num_rain.rng_max - prop.num_rain.rng_min)});
                points.num_snow.push({x: x, y: originY - cHeight * (monthly[i].num_snow - prop.num_snow.rng_min) / (prop.num_snow.rng_max - prop.num_snow.rng_min)});
                points.num_storm.push({x: x, y: originY - cHeight * (monthly[i].num_storm - prop.num_storm.rng_min) / (prop.num_storm.rng_max - prop.num_storm.rng_min)});
                points.num_fire.push({x: x, y: originY - cHeight * (monthly[i].num_fire - prop.num_fire.rng_min) / (prop.num_fire.rng_max - prop.num_fire.rng_min)});
                points.max_level_fire.push({x: x, y: originY - cHeight * (monthly[i].max_level_fire - prop.max_level_fire.rng_min) / (prop.max_level_fire.rng_max - prop.max_level_fire.rng_min)});
            }
        }

        for (let i = 0; i < monthly.length; i++) {
            let A1 = [];
            A1[0] = monthly[i].year + "-" + monthly[i].month;

            let A2 = [];
            A2[0] = monthly[i].avg_temp;
            A2[1] = monthly[i].amt_rain;
            A2[2] = monthly[i].num_rain;
            A2[3] = monthly[i].num_snow;

            A1[1] = A2;
            dataArr.push(A1);
        }

        drawLineLabelMarkers();

        drawPlot();

        drawDragBar();

        function drawLineLabelMarkers() {
            ctx.font = "24px Arial";
            ctx.lineWidth = 2;
            ctx.fillStyle = "#000000";
            ctx.strokeStyle = "#000000";
            drawLineWithColor(originX, originY, originX, cMargin, "white");
            drawLineWithColor(originX, originY, originX + cWidth, originY, "white");
            drawMarkers();
        }

        function drawLineWithColor(x, y, X, Y, color) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(X, Y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
        }


        function drawMarkers() {
            ctx.strokeStyle = "#E0E0E0";
            // 绘制 y
            let oneVal = (maxValue - minValue) / totalYNumber;
            ctx.textAlign = "right";
            for (let i = 1; i <= totalYNumber; i++) {
                let markerVal = Number.parseInt(i * oneVal + minValue).toString();
                let xMarker = originX - 10;
                let yMarker = originY - cHeight * (markerVal - minValue) / (maxValue - minValue);
                ctx.fillStyle = "white";
                ctx.font = "22px Verdana";
                ctx.fillText(markerVal, xMarker - 15, yMarker, cSpace);
                if (i > 0) {
                    drawLineWithColor(originX + 1, yMarker - 3, originX - 9, yMarker - 3, "white");
                }
            }

            // 绘制 x
            let textNb = 6;
            ctx.textAlign = "center";
            for (let i = 0; i < totalBars; i++) {
                if (totalBars > textNb && i % parseInt(totalBars / 10) !== 0) {
                    continue;
                }
                let markerVal = dataArr[i][0];
                let xMarker = parseInt(originX + cWidth * (i / totalBars) + bMargin + bWidth / 2);
                let yMarker = originY + 30;
                ctx.fillStyle = "white";
                ctx.font = "22px Verdana";
                ctx.fillText(markerVal, xMarker, yMarker, cSpace); // 文字
                if (i > 0) {
                    drawLineWithColor(xMarker, originY, xMarker, originY - 10, "white");
                }
            }
            // 绘制标题 y
            ctx.save();
            ctx.rotate(-Math.PI / 2);
            //ctx.fillText("指 数", -canvas.height / 2, cSpace - 20);
            ctx.restore();
            // 绘制标题 x
            //ctx.fillText("日 期", originX + cWidth / 2, originY + cSpace - 20);
        }

        function drawPlot() {
            point_avg_temp = [];
            point_amt_rain = [];
            point_num_rain = [];
            for (let i = 0; i < totalBars; i++) {
                let x = originX + (bWidth + bMargin) * i + bMargin;

                point_avg_temp.push({x: x + bWidth / 2, y: originY - cHeight * (monthly[i].avg_temp - minValue) / (maxValue - minValue)});
                point_amt_rain.push({x: x + bWidth / 2, y: originY - cHeight * (monthly[i].amt_rain - minValue) / (maxValue - minValue)});
                point_num_rain.push({x: x + bWidth / 2, y: originY - cHeight * (monthly[i].num_rain - minValue) / (maxValue - minValue)});
            }

            drawBezier(point_avg_temp, "rgba(251,61,95,1)");
            drawBezier(point_amt_rain, "rgb(47,69,84)");
            drawBezier(point_num_rain, "rgb(97,160,168)");
        }

        function drawBezier(point, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.font = "20px SimSun";
            ctx.fillStyle = "#ffffff";
            for (let i = 0; i < point.length; i++) {
                if (i === 0) {
                    ctx.moveTo(point[i].x, point[i].y);
                } else {
                    let ctrlP = getCtrlPoint(point, i - 1);
                    ctx.bezierCurveTo(ctrlP.pA.x, ctrlP.pA.y, ctrlP.pB.x, ctrlP.pB.y, point[i].x, point[i].y);
                    // ctx.fillText("("+point[i].x+","+point[i].y+")",point[i].x,point[i].y);
                }
            }
            ctx.stroke();
        }


        function getCtrlPoint(ps, i) {
            let a = 0.25;
            let b = 0.25;

            let pAx, pAy, pBx, pBy;

            if (i < 1) {
                pAx = ps[0].x + (ps[1].x - ps[0].x) * a;
                pAy = ps[0].y + (ps[1].y - ps[0].y) * a;
            } else {
                pAx = ps[i].x + (ps[i + 1].x - ps[i - 1].x) * a;
                pAy = ps[i].y + (ps[i + 1].y - ps[i - 1].y) * a;
            }
            if (i > ps.length - 3) {
                let last = ps.length - 1
                pBx = ps[last].x - (ps[last].x - ps[last - 1].x) * b;
                pBy = ps[last].y - (ps[last].y - ps[last - 1].y) * b;
            } else {
                pBx = ps[i + 1].x - (ps[i + 2].x - ps[i].x) * b;
                pBy = ps[i + 1].y - (ps[i + 2].y - ps[i].y) * b;
            }

            return {
                pA: {x: pAx, y: pAy},
                pB: {x: pBx, y: pBy}
            }
        }

        //绘制方块
        function drawRect(x, y, X, Y, mouseMove, color, ifBigBar, ifDrag) {

            ctx.beginPath();

            if (parseInt(x) % 2 !== 0) { //避免基数像素在普通分辨率屏幕上出现方块模糊的情况
                x += 0;
            }
            if (parseInt(y) % 2 !== 0) {
                y += 0;
            }
            if (parseInt(X) % 2 !== 0) {
                X += 0;
            }
            if (parseInt(Y) % 2 !== 0) {
                Y += 0;
            }
            ctx.rect(parseInt(x), parseInt(y), parseInt(X), parseInt(Y));

            if (ifBigBar && mouseMove && ctx.isPointInPath(mousePosition.x * 2, mousePosition.y * 2)) { //如果是鼠标移动的到柱状图上，重新绘制图表
                ctx.strokeStyle = color;
                ctx.strokeWidth = 20;
                ctx.stroke();
            }
            //如果移动到拖动选择范围按钮
            canvas.style.cursor = "default";
            if (ifDrag && ctx.isPointInPath(mousePosition.x * 2, mousePosition.y * 2)) { //如果是鼠标移动的到调节范围按钮上，改变鼠标样式
                canvas.style.cursor = "all-scroll";
            }
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();

        }


        function drawDragBar() {
            drawRect(originX, originY + cSpace, cWidth, cMargin, false, "white");
            drawRect(originX, originY + cSpace, dragBarX - originX, cMargin, false, "rgb(87,93,110)");
            drawRect(dragBarX, originY + cSpace, dragBarWidth, cMargin, false, "red", false, true);
        }

        //检测鼠标移动
        let mouseTimer = null;
        addMouseMove();

        function addMouseMove() {
            canvas.addEventListener("mousemove", function (e) {
                let x = event.pageX - canvas.getBoundingClientRect().left - 60;
                let y = -event.pageY + canvas.getBoundingClientRect().top + 400;
                if (y > 0 && x > 0) {
                    let positionx = 1;
                    for (let i = 0; i < totalBars; i++) {
                        if (x >= (1080 / totalBars) * i) {
                            positionx = i + 1;
                        }
                    }
                    let xx = originX + ((bWidth + bMargin) * (positionx - 1) + bMargin);

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawLineLabelMarkers();
                    drawPlot();
                    drawDragBar();
                    drawLineWithColor(xx + bWidth / 2 - 1, 40, xx + bWidth / 2 - 1, 800);
                    drawDashLine(ctx, 120, canvas.getBoundingClientRect().top + event.pageY * 2 - 90, 760 * 3, canvas.getBoundingClientRect().top + event.pageY * 2 - 90, 5);


                    let vx = 10;
                    let vy = canvas.getBoundingClientRect().top + event.pageY * 2 - 90 - 20;
                    ctx.beginPath();
                    ctx.moveTo(vx, vy);
                    ctx.lineTo(vx + 100, vy);
                    ctx.lineTo(vx + 100, vy + 40);
                    ctx.lineTo(vx, vy + 40);
                    ctx.lineTo(vx, vy);
                    ctx.lineWidth = 2;
                    ctx.fillStyle = "rgb(104,113,130)";
                    ctx.fill();
                    ctx.stroke();


                    let ch = parseFloat((maxValue - minValue) * y * 2 / cHeight + minValue).toFixed(2);

                    ctx.fillStyle = "white";
                    ctx.fillText(ch, vx + 50, vy + 30, 50); // 文字


                    vx = xx + bWidth / 2 - 1 + 20;
                    vy = canvas.getBoundingClientRect().top + event.pageY * 2 - 90 + 20;
                    ctx.beginPath();
                    ctx.moveTo(vx, vy);
                    ctx.lineTo(vx + 200, vy);
                    ctx.lineTo(vx + 200, vy + 330);
                    ctx.lineTo(vx, vy + 330);
                    ctx.lineTo(vx, vy);
                    ctx.lineWidth = 2;
                    ctx.fillStyle = "rgba(104,113,130,0.5)";
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = "white";
                    ctx.textAlign = "left";
                    // ctx.fillText(dataArr[positionx - 1][0], vx + 20, vy + 30, 150);
                    // ctx.fillText("开盘价：" + dataArr[positionx - 1][1][0], vx + 20, vy + 70, 150);
                    // ctx.fillText("收盘价：" + dataArr[positionx - 1][1][1], vx + 20, vy + 105, 150);
                    // ctx.fillText("最高价：" + dataArr[positionx - 1][1][2], vx + 20, vy + 140, 150);
                    // ctx.fillText("最低价：" + dataArr[positionx - 1][1][3], vx + 20, vy + 175, 150);
                    ctx.fillText("平均气温：" + monthly[positionx - 1].avg_temp, vx + 20, vy + 210, 150);
                    ctx.fillText("降雨量：" + monthly[positionx - 1].amt_rain, vx + 20, vy + 245, 150);
                    ctx.fillText("降雨天数：" + monthly[positionx - 1].num_rain, vx + 20, vy + 280, 150);


                } else {
                    e = e || window.event;
                    if (e.offsetX || e.offsetX === 0) {
                        mousePosition.x = e.offsetX;
                        mousePosition.y = e.offsetY;
                    } else if (e.layerX || e.layerX === 0) {
                        mousePosition.x = e.layerX;
                        mousePosition.y = e.layerY;
                    }

                    clearTimeout(mouseTimer);
                    mouseTimer = setTimeout(function () {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawLineLabelMarkers();
                        drawPlot();
                        drawDragBar();
                    }, 10);
                }


            });
        }

        canvas.onmousedown = function (e) {

            document.onmousemove = function (e) {
                if (e.offsetX || e.offsetX === 0) {
                    dragBarX = e.offsetX * 2 - dragBarWidth / 2;
                } else if (e.layerX || e.layerX === 0) {
                    dragBarX = e.layerX * 2 - dragBarWidth / 2;
                }

                if (dragBarX <= originX) {
                    dragBarX = originX
                }
                if (dragBarX > originX + cWidth - dragBarWidth) {
                    dragBarX = originX + cWidth - dragBarWidth
                }

                totalBars = Math.ceil(dataArr.length * ((dragBarX - cMargin - cSpace) / cWidth));
                bWidth = cWidth / totalBars / 3;
                bMargin = (cWidth - bWidth * totalBars) / (totalBars + 1);
            }

            document.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
            }
        }

        function getBeveling(x, y) {
            return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        }

        function drawDashLine(context, x1, y1, x2, y2, dashLen) {
            dashLen = dashLen === undefined ? 5 : dashLen;
            //得到斜边的总长度
            let beveling = getBeveling(x2 - x1, y2 - y1);
            //计算有多少个线段
            let num = Math.floor(beveling / dashLen);

            for (let i = 0; i < num; i++) {
                context[i % 2 === 0 ? 'moveTo' : 'lineTo'](x1 + (x2 - x1) / num * i, y1 + (y2 - y1) / num * i);
            }
            context.stroke();
        }
    }

    drawRightUpPanel();
</script>
</body>

</html>