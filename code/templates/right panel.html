<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K线图实例</title>
    <style type="text/css">
        body {
            background-color: rgb(33, 33, 45);
        }
    </style>
</head>

<body>

<div id="chart" height="500" width="1200" style="margin:30px;"></div>
<script src="http://192.168.1.100:5000/static/monthly.js"></script>
<script type="text/javascript">
    let begin = new Date(0);
    begin.setFullYear(2020);
    begin.setMonth(7);
    let end = new Date(0);
    end.setFullYear(2021);
    end.setMonth(1);
    // [
    //     {'year': 2007, 'month': 1, 'avg_temp': 5.5, 'amt_rain': 84.5, 'num_rain': 14, 'num_snow': 4, 'num_storm': 0, 'num_fire': 8, 'max_level_fire': 1},
    //     {'year': 2007, 'month': 2, 'avg_temp': 11.2, 'amt_rain': 56.7, 'num_rain': 10, 'num_snow': 0, 'num_storm': 0, 'num_fire': 10, 'max_level_fire': 1}
    // ];
    function drawRightUpPanel() {

        let mousePosition = {}; //用户存放鼠标位置

        let canvas = document.createElement("canvas");
        let ctx = canvas.getContext("2d");

        let cBox = document.getElementById("chart");
        cBox.appendChild(canvas);

        let cMargin = 20;
        let cSpace = 80;

        canvas.width = cBox.getAttribute("width") * 2;
        canvas.height = cBox.getAttribute("height") * 2;
        canvas.style.height = canvas.height / 2 + "px";
        canvas.style.width = canvas.width / 2 + "px";
        let cHeight = canvas.height - cMargin * 2 - cSpace * 2;
        let cWidth = canvas.width - cMargin * 2 - cSpace * 2;
        let originX = cMargin + cSpace;
        let originY = cMargin + cHeight;

        // 柱状图信息
        let totalBars = monthly.length;
        let bWidth = cWidth / totalBars / 3;
        let bMargin = (cWidth - bWidth * totalBars) / (totalBars + 1);
        let totalXNumber = 5;

        let dragBarWidth = 10;
        let dragBarX = cWidth + cSpace + cMargin - dragBarWidth;


        drawRightUpPanel.properties = {
            'avg_temp': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(251, 61, 95, 1)', 'show': false},
            'amt_rain': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(47, 69, 84, 1)', 'show': false},
            'num_rain': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(97, 160, 168, 1)', 'show': false},
            'num_snow': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(97, 160, 168, 1)', 'show': false},
            'num_storm': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)', 'show': false},
            'num_fire': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)', 'show': false},
            'max_level_fire': {'rng_min': Number.POSITIVE_INFINITY, 'rng_max': Number.NEGATIVE_INFINITY, 'color': 'rgba(0, 0, 0, 1)', 'show': false},
        }
        drawRightUpPanel.property_list = [
            'avg_temp',
            'amt_rain',
            'num_rain',
            'num_snow',
            'num_storm',
            'num_fire',
            'max_level_fire'
        ]

        drawRightUpPanel.points = {
            'avg_temp': [],
            'amt_rain': [],
            'num_rain': [],
            'num_snow': [],
            'num_storm': [],
            'num_fire': [],
            'max_level_fire': [],
        }
        loaded();

        function loaded() {
            let prop = drawRightUpPanel.properties;
            for (const monthlyElement of monthly) {
                prop.avg_temp.rng_max = Math.max(prop.avg_temp.rng_max, monthlyElement.avg_temp);
                prop.avg_temp.rng_min = Math.min(prop.avg_temp.rng_min, monthlyElement.avg_temp);

                prop.amt_rain.rng_max = Math.max(prop.amt_rain.rng_max, monthlyElement.amt_rain);
                prop.amt_rain.rng_min = Math.min(prop.amt_rain.rng_min, monthlyElement.amt_rain);

                prop.num_rain.rng_max = Math.max(prop.num_rain.rng_max, monthlyElement.num_rain);
                prop.num_rain.rng_min = Math.min(prop.num_rain.rng_min, monthlyElement.num_rain);

                prop.num_snow.rng_max = Math.max(prop.num_snow.rng_max, monthlyElement.num_snow);
                prop.num_snow.rng_min = Math.min(prop.num_snow.rng_min, monthlyElement.num_snow);

                prop.num_storm.rng_max = Math.max(prop.num_storm.rng_max, monthlyElement.num_storm);
                prop.num_storm.rng_min = Math.min(prop.num_storm.rng_min, monthlyElement.num_storm);

                prop.num_fire.rng_max = Math.max(prop.num_fire.rng_max, monthlyElement.num_fire);
                prop.num_fire.rng_min = Math.min(prop.num_fire.rng_min, monthlyElement.num_fire);

                prop.max_level_fire.rng_max = Math.max(prop.max_level_fire.rng_max, monthlyElement.max_level_fire);
                prop.max_level_fire.rng_min = Math.min(prop.max_level_fire.rng_min, monthlyElement.max_level_fire);
            }
            Object.keys(drawRightUpPanel.properties).forEach(key => {
                let diff = 0.05 * (drawRightUpPanel.properties[key].rng_max - drawRightUpPanel.properties[key].rng_min);
                drawRightUpPanel.properties[key].rng_max += diff;
                drawRightUpPanel.properties[key].rng_min -= diff;
            });

            let points = drawRightUpPanel.points;
            for (let i = 0; i < monthly.length; i++) {
                let x = originX + (bWidth + bMargin) * i + bMargin + bWidth / 2;

                points.avg_temp.push({x: x, y: originY - cHeight * (monthly[i].avg_temp - prop.avg_temp.rng_min) / (prop.avg_temp.rng_max - prop.avg_temp.rng_min)});
                points.amt_rain.push({x: x, y: originY - cHeight * (monthly[i].amt_rain - prop.amt_rain.rng_min) / (prop.amt_rain.rng_max - prop.amt_rain.rng_min)});
                points.num_rain.push({x: x, y: originY - cHeight * (monthly[i].num_rain - prop.num_rain.rng_min) / (prop.num_rain.rng_max - prop.num_rain.rng_min)});
                points.num_snow.push({x: x, y: originY - cHeight * (monthly[i].num_snow - prop.num_snow.rng_min) / (prop.num_snow.rng_max - prop.num_snow.rng_min)});
                points.num_storm.push({x: x, y: originY - cHeight * (monthly[i].num_storm - prop.num_storm.rng_min) / (prop.num_storm.rng_max - prop.num_storm.rng_min)});
                points.num_fire.push({x: x, y: originY - cHeight * (monthly[i].num_fire - prop.num_fire.rng_min) / (prop.num_fire.rng_max - prop.num_fire.rng_min)});
                points.max_level_fire.push({x: x, y: originY - cHeight * (monthly[i].max_level_fire - prop.max_level_fire.rng_min) / (prop.max_level_fire.rng_max - prop.max_level_fire.rng_min)});
            }
            drawLineLabelMarkers();
            drawPlot();
            drawTime();
        }


        function drawTime() {
            let radius = 15;
            if (begin.getTime() === end.getTime()) {
                let x = originX + (bWidth + bMargin) * getIdx(begin) + bMargin + bWidth / 2;
                drawLineWithColor(x + bWidth / 2 - 1, cMargin, x + bWidth / 2 - 1, originY, "rgb(255, 255, 255, 0.7)");
                drawRightUpPanel.ctrl1 = drawFilledCircleWithColor(x + bWidth / 2 - 1, cMargin, radius, "rgb(255, 255, 255, 1)");
                drawRightUpPanel.ctrl2 = undefined;
            } else {
                let x1 = originX + (bWidth + bMargin) * getIdx(begin) + bMargin + bWidth / 2;
                let x2 = originX + (bWidth + bMargin) * getIdx(end) + bMargin + bWidth / 2;
                drawRect(x1 + bWidth / 2 - 1, cMargin, x2 - x1, originY - cMargin, false, "rgb(255, 255, 255, 0.2)", true);

                drawLineWithColor(x1 + bWidth / 2 - 1, cMargin, x1 + bWidth / 2 - 1, originY, "rgb(255, 255, 255, 0.7)");
                drawRightUpPanel.ctrl1 = drawFilledCircleWithColor(x1 + bWidth / 2 - 1, cMargin, radius, "rgb(255, 255, 255, 1)");

                drawLineWithColor(x2 + bWidth / 2 - 1, cMargin, x2 + bWidth / 2 - 1, originY, "rgb(255, 255, 255, 0.7)");
                drawRightUpPanel.ctrl2 = drawFilledCircleWithColor(x2 + bWidth / 2 - 1, cMargin, radius, "rgb(255, 255, 255, 1)");
            }

            function getIdx(timestamp) {
                for (let i = 0; i < monthly.length; i++) {
                    if (timestamp.getFullYear() <= monthly[i].year && timestamp.getMonth() <= monthly[i].month) {
                        // console.log(i)
                        return i;
                    }
                }
                return monthly.length - 1;
            }
        }

        function drawLineLabelMarkers() {
            ctx.font = "24px Arial";
            ctx.lineWidth = 2;
            ctx.fillStyle = "#000000";
            ctx.strokeStyle = "#000000";
            drawLineWithColor(originX, originY, originX + cWidth, originY, "white");
            drawLineWithColor(originX, cMargin, originX + cWidth, cMargin, "white");
            drawXMarkers();
        }

        function drawLineWithColor(x, y, X, Y, color) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(X, Y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
        }

        function drawFilledCircleWithColor(x, y, radius, color) {
            ctx.beginPath();
            ctx.fillStyle = color;
            let path = new Path2D();
            path.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill(path);
            return path;
        }


        function drawXMarkers() {
            ctx.strokeStyle = "#E0E0E0";
            ctx.textAlign = "center";
            for (let i = 0; i < totalBars; i++) {
                if (i % parseInt(totalBars / totalXNumber) === 0) {
                    let markerVal = monthly[i].year + '-' + monthly[i].month;
                    let xMarker = parseInt(originX + cWidth * (i / totalBars) + bMargin + bWidth / 2);
                    let yMarker = originY + 30;
                    ctx.fillStyle = "white";
                    ctx.font = "22px Verdana";
                    ctx.fillText(markerVal, xMarker, yMarker, cSpace);
                    if (i > 0) {
                        drawLineWithColor(xMarker, originY, xMarker, originY - 10, "white");
                    }
                }
            }
        }

        function drawPlot() {
            for (const propertyListKey of drawRightUpPanel.property_list) {
                let color = drawRightUpPanel.properties[propertyListKey].color;
                if (!drawRightUpPanel.properties[propertyListKey].show) color = color.replace(/[^,]+(?=\))/, " 0.1");
                drawBezier(drawRightUpPanel.points[propertyListKey], color);
            }
        }

        function drawBezier(point, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.font = "20px SimSun";
            ctx.fillStyle = "#ffffff";
            for (let i = 0; i < point.length; i++) {
                if (i === 0) {
                    ctx.moveTo(point[i].x, point[i].y);
                } else {
                    let ctrlP = getCtrlPoint(point, i - 1);
                    ctx.bezierCurveTo(ctrlP.pA.x, ctrlP.pA.y, ctrlP.pB.x, ctrlP.pB.y, point[i].x, point[i].y);
                    // ctx.fillText("("+point[i].x+","+point[i].y+")",point[i].x,point[i].y);
                }
            }
            ctx.stroke();
        }


        function getCtrlPoint(ps, i) {
            let a = 0.25;
            let b = 0.25;

            let pAx, pAy, pBx, pBy;

            if (i < 1) {
                pAx = ps[0].x + (ps[1].x - ps[0].x) * a;
                pAy = ps[0].y + (ps[1].y - ps[0].y) * a;
            } else {
                pAx = ps[i].x + (ps[i + 1].x - ps[i - 1].x) * a;
                pAy = ps[i].y + (ps[i + 1].y - ps[i - 1].y) * a;
            }
            if (i > ps.length - 3) {
                let last = ps.length - 1
                pBx = ps[last].x - (ps[last].x - ps[last - 1].x) * b;
                pBy = ps[last].y - (ps[last].y - ps[last - 1].y) * b;
            } else {
                pBx = ps[i + 1].x - (ps[i + 2].x - ps[i].x) * b;
                pBy = ps[i + 1].y - (ps[i + 2].y - ps[i].y) * b;
            }

            return {
                pA: {x: pAx, y: pAy},
                pB: {x: pBx, y: pBy}
            }
        }

        //绘制方块
        function drawRect(x, y, X, Y, mouseMove, color, ifDrag) {

            ctx.beginPath();
            ctx.rect(parseInt(x), parseInt(y), parseInt(X), parseInt(Y));

            if (ifDrag && ctx.isPointInPath(mousePosition.x * 2, mousePosition.y * 2)) { //如果是鼠标移动的到调节范围按钮上，改变鼠标样式
                canvas.style.cursor = "ew-resize";
                // canvas.style.cursor = "all-scroll";
            } else if (ifDrag) {
                canvas.style.cursor = "default";
            }
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();

        }

        addMouseMove();

        function addMouseMove() {
            canvas.addEventListener("mousemove", function (e) {
                mousePosition.x = e.offsetX;
                mousePosition.y = e.offsetY;

                let x = e.offsetX - originX / 2;
                let y = e.offsetY - cMargin / 2;
                if (y > 0 && x > 0) {
                    let positionx = 1;
                    for (let i = 0; i < totalBars; i++) {
                        if (x >= (cWidth / 2 / totalBars) * i) {
                            positionx = i + 1;
                        }
                    }
                    let xx = originX + ((bWidth + bMargin) * (positionx - 1) + bMargin);

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawLineLabelMarkers();
                    drawPlot();
                    drawTime();
                    drawLineWithColor(xx + bWidth / 2 - 1, cMargin, xx + bWidth / 2 - 1, cMargin + cHeight, "white");
                    drawDashLine(ctx, 110, canvas.getBoundingClientRect().top + event.pageY * 2 - 90, 760 * 3 + 10, canvas.getBoundingClientRect().top + event.pageY * 2 - 90, 5);


                    let vx = xx + bWidth / 2 - 1 + 20;
                    let vy = canvas.getBoundingClientRect().top + event.pageY * 2 - 90 + 20;
                    ctx.beginPath();
                    ctx.moveTo(vx, vy);
                    ctx.lineTo(vx + 200, vy);
                    ctx.lineTo(vx + 200, vy + 330);
                    ctx.lineTo(vx, vy + 330);
                    ctx.lineTo(vx, vy);
                    ctx.lineWidth = 2;
                    ctx.fillStyle = "rgba(104,113,130,0.5)";
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = "white";
                    ctx.textAlign = "left";
                    ctx.font = "26px Verdana";
                    ctx.fillText(monthly[positionx - 1].year + "-" + monthly[positionx - 1].month, vx + 20, vy + 30, 150);
                    ctx.font = "22px Verdana";
                    ctx.fillText("平均气温：" + monthly[positionx - 1].avg_temp, vx + 20, vy + 70, 150);
                    ctx.fillText("降雨量：" + monthly[positionx - 1].amt_rain, vx + 20, vy + 105, 150);
                    ctx.fillText("降雨天数：" + monthly[positionx - 1].num_rain, vx + 20, vy + 140, 150);
                    ctx.fillText("降雪天数：" + monthly[positionx - 1].num_snow, vx + 20, vy + 175, 150);
                    ctx.fillText("暴雨天数：" + monthly[positionx - 1].num_storm, vx + 20, vy + 210, 150);
                    ctx.fillText("火灾数量：" + monthly[positionx - 1].num_fire, vx + 20, vy + 245, 150);
                    ctx.fillText("最大火灾：" + monthly[positionx - 1].max_level_fire, vx + 20, vy + 280, 150);


                } else {
                    e = e || window.event;
                    if (e.offsetX || e.offsetX === 0) {
                        mousePosition.x = e.offsetX;
                        mousePosition.y = e.offsetY;
                    } else if (e.layerX || e.layerX === 0) {
                        mousePosition.x = e.layerX;
                        mousePosition.y = e.layerY;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawLineLabelMarkers();
                    drawPlot();
                    drawTime();
                }
            });
        }

        canvas.onmousedown = function (e) {
            if (ctx.isPointInPath(drawRightUpPanel.ctrl1, e.offsetX * 2, e.offsetY * 2)) {
                drawRightUpPanel.modifyCtrl1 = true;
                drawRightUpPanel.modifyCtrl2 = false;
            } else if (drawRightUpPanel.ctrl2 && ctx.isPointInPath(drawRightUpPanel.ctrl2, e.offsetX * 2, e.offsetY * 2)) {
                drawRightUpPanel.modifyCtrl1 = false;
                drawRightUpPanel.modifyCtrl2 = true;
            }

            document.onmousemove = function (e) {
                let x = e.offsetX - originX / 2;
                let positionX = 1;
                for (let i = 0; i < totalBars; i++) {
                    if (x >= (cWidth / 2 / totalBars) * i) {
                        positionX = i + 1;
                    }
                }
                if (drawRightUpPanel.modifyCtrl1) {
                    let newTime = new Date(0);
                    newTime.setFullYear(monthly[positionX - 1].year);
                    newTime.setMonth(monthly[positionX - 1].month);
                    if (newTime.getTime() > end.getTime()) {
                        end.setFullYear(newTime.getFullYear());
                        end.setMonth(newTime.getMonth());
                            drawRightUpPanel.modifyCtrl1 = false;
                            drawRightUpPanel.modifyCtrl2 = true;
                    } else {
                        begin = newTime;
                    }
                } else if (drawRightUpPanel.modifyCtrl2) {
                    end.setFullYear(monthly[positionX - 1].year);
                    end.setMonth(monthly[positionX - 1].month);
                    if (end.getTime() < begin.getTime()) {
                        end.setFullYear(begin.getFullYear());
                        end.setMonth(begin.getMonth());
                    }
                }
                console.log(begin.getTime() > end.getTime())
            }

            document.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
                drawRightUpPanel.modifyCtrl1 = false;
                drawRightUpPanel.modifyCtrl2 = false;
            }
        }

        function getBeveling(x, y) {
            return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        }

        function drawDashLine(context, x1, y1, x2, y2, dashLen) {
            dashLen = dashLen === undefined ? 5 : dashLen;
            //得到斜边的总长度
            let beveling = getBeveling(x2 - x1, y2 - y1);
            //计算有多少个线段
            let num = Math.floor(beveling / dashLen);

            for (let i = 0; i < num; i++) {
                context[i % 2 === 0 ? 'moveTo' : 'lineTo'](x1 + (x2 - x1) / num * i, y1 + (y2 - y1) / num * i);
            }
            context.stroke();
        }
    }

    drawRightUpPanel();
</script>
</body>

</html>