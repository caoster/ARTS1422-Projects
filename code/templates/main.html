<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Fire Station</title>
</head>

<body>
<div style="width: 1000px; height: 800px;">
    <svg width="1000" height="800"></svg>
    <h1>123</h1>
</div>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
<script>
    function getColor() {
        if (!('count' in getColor))
            getColor.count = 0;
        let scheme1 = ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'];
        let scheme2 = ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
        if (getColor.count >= scheme1.length) return '#FFFFFF'
        return scheme1[getColor.count++]
    }

    const svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    const x_move_factor = width / 2;
    const y_move_factor = height / 2;

    const gfg = d3
        .geoMercator()
        .scale(width * 20)
        .rotate([0, 0])
        .center([119.5, 29.9])
        .translate([0, 0]);

    g = svg.append("g")
        .attr("transform", `translate(${x_move_factor},${y_move_factor})`).on("mousemove", function () {
            let coord = gfg.invert(d3.mouse(this));
            d3.select("h1").text(`${coord[0].toFixed(3)}, ${coord[1].toFixed(3)}`);
        });

    d3.json(
        "../data/geojson.json",
        function (data) {
            g.append("image")
                .attr('id', 'map')
                .attr("xlink:href", "map.jpg")
                .attr("transform", `translate(${-width},${-height}) scale(0.5)`);

            g.selectAll("path").data(data.features).enter().append("path") /* data.features to fill */
                .attr("fill", "#FFFFFF")
                .attr("fill-opacity", "0.2")
                .attr("d", d3.geoPath().projection(gfg))
                .style("stroke", "#000000")
                .style("stroke-width", "0.3px");

            // g.selectAll(".pin").data(places).enter().append("circle")
            //                 .attr("r", 5)
            //     .attr("transform", function (d) {
            //         return "translate(" + projection([
            //             d.location.longitude,
            //             d.location.latitude
            //         ]) + ")";
            //     });

            // TODO: display fire station here

            // https://stackoverflow.com/questions/32734822/svg-d3-js-how-to-selectall-using-condition
        });

    g1 = svg.append("g")
        .attr("transform", `translate(${x_move_factor},${y_move_factor})`);

    d3.json(
        "../data/fire.json",
        function (data) {
            for (let key in data) {
                let color = getColor();
                if (color === "#FFFFFF") break; // TODO: remove this line
                g1.selectAll(".pin").data(data[key]).enter().append("circle")
                    .attr("class", "datapoint")
                    .attr("r", 4)
                    .attr("fill", "red")
                    .attr("fill-opacity", "0.01")
                    .attr("transform", function (d) {
                        return "translate(" + gfg([d["lon"], d["lat"]]) + ")";
                    });
            }
        });

    console.log(gfg.invert([1000, 800]));
    console.log(gfg.invert([-1000, -800]));

    // para axis
    svg2 = d3.select("body")
        .append("svg")
        .attr("width", 1100)
        .attr("height", 1800);
    d3.json("../data/fire_mul.json",function(data){
        // for (let i = 0; i < data.length; i++) {
        //     data[i].month = parseFloat(data[i].month)
        //     data[i].population = parseFloat(data[i].population)
        // }
        data = data.features
        var population_range = [d3.min(data,function(d){   
                return d.population;}),
            d3.max(data,function(d){   
                return d.population;})
        ];

        var scale1 = d3.scaleLinear()
            .domain([1,12])
            .range([480,0]);
        var scale1_r = d3.scaleLinear()
            .domain([1,365])
            .range([520,0]);
        var axis1 = d3.axisLeft(scale1);
        svg2.append("g")
            .attr("transform","translate("+100+","+200+")")
            .call(axis1);

        var scale2 = d3.scaleLinear()
            .domain([2007,2020])
            .range([520,0]);
        var axis2 = d3.axisLeft(scale2);
        svg2.append("g")
            .attr("transform","translate("+300+","+200+")")
            .call(axis2);
        
        var scale3 = d3.scaleLinear()
            .domain(population_range)
            .range([520,0]);
        var axis3 = d3.axisLeft(scale3);
        svg2.append("g")
            .attr("transform","translate("+500+","+200+")")
            .call(axis3);

        var color = d3.color("blue");
        color.opacity = 0.07
        svg2.selectAll(".paracool").data(data).enter()
            .append("line")
            .attr("class", "paracool")
            .attr("x1",100)
            .attr("x2",300)
            .attr("y1",(d) => scale1_r(d.day)+200)
            .attr("y2",(d) => scale2(d.year)+200)
            .attr("stroke",color)
            .attr("stroke-width", "0.1")
            // .attr("fill-opacity", "0.1")
    })

    let zoom = d3.zoom()
        .scaleExtent([1, 15])
        .translateExtent([[-width / 2, -height / 2], [width * 3 / 2, height * 3 / 2]])
        .on("zoom", function () {
            g.attr("transform", `translate(${d3.event.transform.x + x_move_factor},${d3.event.transform.y + y_move_factor}) scale(${d3.event.transform.k})`);
            g1.attr("transform", `translate(${d3.event.transform.x + x_move_factor},${d3.event.transform.y + y_move_factor}) scale(${d3.event.transform.k})`);
            g1.selectAll(".datapoint").attr("r", 4 / d3.event.transform.k);
        })

    svg.call(zoom);

</script>
</body>
</html>
