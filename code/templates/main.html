<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Fire Station</title>
</head>

<body>
<div style="width: 1000px; height: 800px;">
    <svg width="1000" height="800"></svg>
    <h1>123</h1>
</div>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
<script>
    function getColor() {
        if (!('count' in getColor))
            getColor.count = 0;
        let scheme1 = ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'];
        let scheme2 = ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
        if (getColor.count >= scheme1.length) return '#FFFFFF'
        return scheme1[getColor.count++]
    }

    const svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    const x_move_factor = width / 2;
    const y_move_factor = height / 2;

    const gfg = d3
        .geoMercator()
        .scale(width * 20)
        .rotate([0, 0])
        .center([119.5, 29.9])
        .translate([0, 0]);

    g = svg.append("g")
        .attr("transform", `translate(${x_move_factor},${y_move_factor})`).on("mousemove", function () {
            let coord = gfg.invert(d3.mouse(this));
            d3.select("h1").text(`${coord[0].toFixed(3)}, ${coord[1].toFixed(3)}`);
        });

    d3.json(
        "../data/geojson.json",
        function (data) {
            g.append("image")
                .attr('id', 'map')
                .attr("xlink:href", "map.jpg")
                .attr("transform", `translate(${-width},${-height}) scale(0.5)`);

            g.selectAll("path").data(data.features).enter().append("path") /* data.features to fill */
                .attr("fill", "#FFFFFF")
                .attr("fill-opacity", "0.2")
                .attr("d", d3.geoPath().projection(gfg))
                .style("stroke", "#000000")
                .style("stroke-width", "0.3px");

            // g.selectAll(".pin").data(places).enter().append("circle")
            //                 .attr("r", 5)
            //     .attr("transform", function (d) {
            //         return "translate(" + projection([
            //             d.location.longitude,
            //             d.location.latitude
            //         ]) + ")";
            //     });

            // TODO: display fire station here

            // https://stackoverflow.com/questions/32734822/svg-d3-js-how-to-selectall-using-condition
        });

    g1 = svg.append("g")
        .attr("transform", `translate(${x_move_factor},${y_move_factor})`);

    d3.json(
        "../data/fire.json",
        function (data) {
            for (let key in data) {
                let color = getColor();
                if (color === "#FFFFFF") break; // TODO: remove this line
                g1.selectAll(".pin").data(data[key]).enter().append("circle")
                    .attr("class", "datapoint")
                    .attr("r", 4)
                    .attr("fill", "red")
                    .attr("fill-opacity", "0.01")
                    .attr("transform", function (d) {
                        return "translate(" + gfg([d["lon"], d["lat"]]) + ")";
                    });
            }
        });

    console.log(gfg.invert([1000, 800]));
    console.log(gfg.invert([-1000, -800]));

    // para coor
    var dimensions = [(d)=>d.year, (d)=>d.day, (d)=>d.rain, (d)=>d.temp]
    var domains = [[2020,2007], [366,1], [0,550],[0,35]]
    var txts = ["year", "month", "temperature", "rain"]
    var scale_pc = []
    var axis_pc = []
    var a,s
    var color = d3.color("blue");
    color.opacity = 0.07

    svg2 = d3.select("body")
        .append("svg")
        .attr("width", 1100)
        .attr("height", 1800);

    d3.json("../data/fire_mul.json",function(data){
        data = data.features
        // var population_range = [d3.min(data,function(d){   
        //         return d.population;}),
        //     d3.max(data,function(d){   
        //         return d.population;})
        // ];

        for (let a = 0; a < dimensions.length; a++) {
            // if (txts[a]=="station"){
            //     s = d3.scaleBand()
            //         .domain("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP")
            //         .range([0,480])
            //         .paddingInner(1);
            //     console.log(s('f'))
            //     scale_pc.push(s);
            // }else{
            s = d3.scaleLinear()
                .domain(domains[a])
                .range([480,0]);
            scale_pc.push(s);
            // }

            if (txts[a]=="month"){
                s = d3.scaleBand()
                    .domain(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", " "])
                    .range([0,480])
                    .paddingInner(1);
            }
            ax = d3.axisLeft(s);
            svg2.append("g")
                .attr("transform",`translate(${a*150 + 150},200)`)
                .call(ax);
            
            if (a > 0) {
                svg2.selectAll(".pc"+a).data(data).enter()
                    .append("line")
                    .attr("class", "pc"+a)
                    .attr("x1",150*a)
                    .attr("x2",150*(1+a))
                    .attr("y1",(d) => scale_pc[a-1](dimensions[a-1](d))+200)
                    .attr("y2",(d) => scale_pc[a](dimensions[a](d))+200)
                    .attr("stroke",color)
                    .attr("stroke-width", "0.1")
            }

        }

        // var scale1 = d3.scaleLinear()
        //     .domain([1,12])
        //     .range([440,0]);
        // var scale1_r = d3.scaleLinear()
        //     .domain([1,365])
        //     .range([480,0]);
        // var axis1 = d3.axisLeft(scale1);
        // svg2.append("g")
        //     .attr("transform","translate("+100+","+200+")")
        //     .call(axis1);

        // var scale2 = d3.scaleLinear()
        //     .domain([2007,2020])
        //     .range([480,0]);
        // var axis2 = d3.axisLeft(scale2);
        // svg2.append("g")
        //     .attr("transform","translate("+300+","+200+")")
        //     .call(axis2);
        
        // var scale3 = d3.scaleLinear()
        //     .domain(population_range)
        //     .range([480,0]);
        // var axis3 = d3.axisLeft(scale3);
        // svg2.append("g")
        //     .attr("transform","translate("+500+","+200+")")
        //     .call(axis3);

        
        // svg2.selectAll(".pc1").data(data).enter()
        //     .append("line")
        //     .attr("class", "pc1")
        //     .attr("x1",100)
        //     .attr("x2",300)
        //     .attr("y1",(d) => scale1_r(d.day)+200)
        //     .attr("y2",(d) => scale2(dems[0](d))+200)
        //     .attr("stroke",color)
        //     .attr("stroke-width", "0.1")
        
        // svg2.selectAll(".pc2").data(data).enter()
        //     .append("line")
        //     .attr("class", "pc2")
        //     .attr("x1",500)
        //     .attr("x2",300)
        //     .attr("y1",(d) => scale3(d.population)+200)
        //     .attr("y2",(d) => scale2(d.year)+200)
        //     .attr("stroke",color)
        //     .attr("stroke-width", "0.1")

    })

    let zoom = d3.zoom()
        .scaleExtent([1, 15])
        .translateExtent([[-width / 2, -height / 2], [width * 3 / 2, height * 3 / 2]])
        .on("zoom", function () {
            g.attr("transform", `translate(${d3.event.transform.x + x_move_factor},${d3.event.transform.y + y_move_factor}) scale(${d3.event.transform.k})`);
            g1.attr("transform", `translate(${d3.event.transform.x + x_move_factor},${d3.event.transform.y + y_move_factor}) scale(${d3.event.transform.k})`);
            g1.selectAll(".datapoint").attr("r", 4 / d3.event.transform.k);
        })

    svg.call(zoom);

</script>
</body>
</html>
